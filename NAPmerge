#!/usr/bin/env perl
#By Thomas J Creedy, thomas@tjcreedy.co.uk

use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path remove_tree);
use File::Copy qw(move);
use File::Which;
use List::Util qw(all any max); 
use Algorithm::Loops qw(NestedLoops);
use Parallel::ForkManager;
use Time::HiRes qw(usleep);
use Cwd qw(cwd);
use Data::Dumper;

########################################################
# INITIALISE VARIABLES AND SET DEFAULTS
#

my $version = "0.0.4"; #02/04/2019
my $help;
my @files;
my $outpath;
my %parameters;
our $verbose;
my $threads = 1;
our $debug;

my $script = basename($0,());

# SET DEFAULTS
$parameters{pearquality} = 0;

# CREATE HELPFILE

my $usage =<<USAGE;

Description:

	This is $script version $version of the NGS Amplicon Pipeline. It takes in a pair or set of paired fastq files and 'assembles' mate pair reads for each pair of files. Input files can be given in any order to the -input option, and pairs will be detected based on file name. File names must have _R1 or _R2 for forward and reverse read sets respectively, and anything after this name will be lost downstream. Mates must already be properly paired before running - this should be the case if you've previously run NAPdemux or NAPtrim.
	
	$script wraps PEAR to carry out merging. You may set PEAR option -q using the -pearquality argument.
	
	Optionally, $script can iterate through multiple values for parameters (i.e. -pearquality). Specify parameter ranges as "a-b/c", where a is the starting value, c is the value by which this increments each iteration, and b is the maximum. Note that if the difference between b and a is not divisible exactly by c, the final value of the parameter range will be a+xc where x is the integer quotient of b/a. I.e. if the range 4-9/2 is given, $script will run 3 times using, in turn, the values 4, 6 then 8. Alternatively, values can be given in a custom range of the form "a,b,c" where the precise values to be used are separated by commas. All combinations of all supplied parameter ranges will be run and the results output in separate folders for each iteration (combination).
	
	Either way, a csv log file is output.
	
	For more information, see https://github.com/tjcreedy/NAPtime/wiki/NAPmerge

Usage:

	Basic mode
	$script -input <file_R1.fq> <file_R2.fq> [<file2_R1.fq> <file2_R2.fq] -outpath <merge/> -pearquality <n> [-threads <n> -verbose]
	
	Parameter iteration mode
	$script -input <file_R1.fq> <file_R2.fq> [<file2_R1.fq> <file2_R2.fq] -outpath <merge/> -pearquality <n-n/n> [-threads <n> -verbose]

Arguments:

	      input:  One or more pairs of fastq files to merge reads within
	    outpath:  Path to a directory in which output files and the log table are written.
	pearquality:  A value or range to pass to PEAR as a -q option. Default 0
	    threads:  Number of CPU threads to use. Default 1.
	    verbose:  Reports on progress.
	       help:  Prints out this helpful message.

USAGE

# SET UP HEADER

my $timedate = timestamp()." ".datestamp();
my $timer = "100000";
my $title =<<TITLE;
  _   _          _____  _   _                 
 | \\ | |   /\\   |  __ \\| | (_)                
 |  \\| |  /  \\  | |__) | |_ _ _ __ ___   ___  
 | . ` | / /\\ \\ |  ___/| __| | '_ ` _ \\ / _ \\ 
 | |\\  |/ ____ \\| |    | |_| | | | | | |  __/ 
 |_| \\_/_/    \\_\\_|     \\__|_|_| |_| |_|\\___| 
TITLE


######################################################
# GET INPUTS AND PARSE
#

GetOptions("input=s{2,}"	=> \@files,
	   "outpath=s"		=> \$outpath,
	   "pearquality=s"	=> \$parameters{pearquality},
	   "threads=i"		=> \$threads,
	   "verbose"		=> \$verbose,
	   "debug"		=> \$debug,
	   "help"		=> \$help) or die "Error: Incorrect options, try \"$script --help\" for more information.\n";

# RUN HEADER

foreach my $line (split '\n',$title){
	print $line,"\n";
	usleep($timer);
}

print "\nWelcome. This is $script version $version, started at $timedate.\n";

print "$usage\n" and exit if($help);

if($debug){
	$verbose = 1;
	print "\n#### Running in debug mode ####\n\n"
}

print "\nChecking your parameters...\n" if $verbose;

# CHECK FOR INPUT FILES

if(scalar @files == 0){
	if($debug){
		warn "No input files, running for debug purposes only. There may be errors.\n";
	} else {
		die "I need me some files to work on, see \"$script --help\" for more information\n";
	}
}


# CHECK MERGING

my $mergetool = "pear";
die "Error: $mergetool not found, is it installed and in the PATH?\n" if(! which $mergetool);

die "Error: please specify --pearquality, see \"$script --help\" for more information\n" if(!defined $parameters{pearquality});

# CHECK OUTPUT DIRECTORY

if(!defined $outpath){
	die "Error: output directory must be specified, see \"$script --help\" for more information\n";
} else {
	make_path($outpath);
}

# VERIFY AND PAIR INPUT FILES

print "\nChecking your files...\n" if $verbose;

my %paired_files = find_pairs(@files);
my $n_file_pairs = keys %paired_files;


######################################################
# SET UP ITERATIONS
#

print "\nParsing iterations...\n" if $verbose;

print "DEBUG: Input parameters:\n",Dumper \%parameters if $debug;

my $iterations = parse_parameters(\%parameters,sort keys %paired_files);

print "DEBUG: Parsed iterations:\n", Dumper $iterations if $debug;

printf "\n$script will run %d iterations on each of %d file pairs\n", scalar keys %$iterations, scalar keys %paired_files;



######################################################
# RUN MERGING
#

# INITIALISE FORKER AND VARIABLES

my $mpm = Parallel::ForkManager->new(1);
my $done_iterations=0;
my %merge_log;
my $total =  (scalar keys %$iterations) * (scalar keys %paired_files);
my $it_threads = $threads/$total;
$it_threads = 1 if($it_threads < 1);

# SET UP COMPLETION CLEANER

$mpm->run_on_finish( sub {
	my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
	$done_iterations++;
	print "Completed $done_iterations/$total merging and filtering iterations\r";
	my $iter = $data_structure_reference->{iter};
	my $name = $data_structure_reference->{name};
	$merge_log{$iter}{$name} = $data_structure_reference->{result};
});

# DO MERGING

printf "\nStarting %d merging iterations using $threads threads\n", scalar keys %$iterations if $verbose;

foreach my $iter (keys %$iterations){
	make_path("$outpath/merge_$iter");
	foreach my $name (keys %paired_files){
		my $pid = $mpm->start and next;
		
		my $out = merge_iteration($mergetool,$iterations,$iter,$name,\%paired_files,$outpath,$it_threads);
		
		$mpm->finish(0, {result => $out, iter => $iter, name => $name});
	}
}

# FINALISE

$mpm->wait_all_children;
print "\n";
print "DEBUG: merge log:\n", Dumper \%merge_log, "\n" if $debug;

# MOVE FILES IF ONLY ONE ITERATION

if(scalar keys %$iterations == 1){
	move "$outpath/merge_1/$_.fq", "$outpath/$_.fq" for keys %paired_files;
	remove_tree("$outpath/merge_1/");
}


######################################################
# DO LOG OUTPUT
#


#Do logging
open my $log, '>', "$outpath/merge.log.csv" or die "Error opening csv log for writing"; #open csv object for writing, and name

print $log join(',',('readname' , 'iteration' , 'pearquality' , 'pcA' , 'pcC' , 'pcG' , 'pcT' , 'uncalled_bases' , 'PEAR_input_reads' , 'PEAR_merged_reads' , 'PEAR_discarded_reads' , 'PEAR_not_merged_reads')),"\n";

foreach my $iter (sort keys %$iterations){
	foreach my $name (sort keys %paired_files){
		print $log "$name,$iter,$merge_log{$iter}{$name}\n";
	}
}

close $log;

print "\nDone: CSV log of read processing written\n";

exit;
sub merge_iteration {
	# Load variables
	my ($mergetool, $iterations, $iter, $name, $pairs, $outpath, $it_threads) = @_;
	
	# Start log line
	my $log = ${$iterations}{$iter}{pearquality};
	
	
	if(! (-z ${$pairs}{$name}[0] and -z ${$pairs}{$name}[1])){
		# MERGING
		
		print "Running $mergetool on $name for iteration $iter with quality threshold ${$iterations}{$iter}{pearquality}\n" if $verbose;
		
		# Create command
		my $merge_cmd = "$mergetool -f ${$pairs}{$name}[0] -r ${$pairs}{$name}[1] -o $outpath/merge_$iter/$name -q ${$iterations}{$iter}{pearquality} -j $it_threads 2>/dev/null";
		
		# Run command
		print "DEBUG: $mergetool command:\n$merge_cmd\n" if $debug;
		
		my $merge_log = `$merge_cmd`;
		
		print "DEBUG: $mergetool log:\n$merge_log\n" if $debug;
		
		# Parse log
		$merge_log =~ /.*A:\s(\d.\d{6})\s*C:\s(\d.\d{6})\s*G:\s(\d.\d{6})\s*T:\s(\d.\d{6})\n\s*(\d*).*Assembled\sreads\s[\.]*:\s([\d|,]*)\s.*Discarded\sreads\s[\.]*:\s([\d|,]*)\s.*Not\sassembled\sreads\s[\.]*:\s([\d|,]*)\s\/\s([\d|,]*).*/s;
		
		my @merge_parse = ($1,$2,$3,$4,$5,$9,$6,$7,$8);
		foreach my $e (@merge_parse){
			if($e){
				$e =~ s/,//g;
				$log .= ",$e";
			} else {
				$log .= ",NA";
			}
		}
		
		# Clean up
		unlink <$outpath/merge_$iter/$name.{unassembled,discarded}*>;
		rename "$outpath/merge_$iter/$name.assembled.fastq", "$outpath/merge_$iter/$name.fq";
		
	} else {
		print "One or both of $name files are empty, merging skipped\n" if $verbose;
		$log .= ",NA,NA,NA,NA,NA,0,0,0,0";
	}
	
	# Finish
	return $log;
}

sub parse_parameters {
	my ($inparams,@names) = @_;
	my @itarray;
	my @paramarray;
#	push @paramarray, "name";
#	push @itarray, \@names;
	foreach my $param (keys %$inparams){
		push @paramarray, $param;
		if ($inparams->{$param} =~ /^(\d+(\.\d+)?)-(\d+(\.\d+)?),(\d+(\.\d+)?)$/ ){
			my @values;
			my $curmax = $1;
			while ($curmax <= $3){
				push @values, $curmax;
				$curmax += $5;
			}
			push @itarray, \@values;
		} elsif($inparams->{$param} =~ /^[a-zA-Z]+(?:,[a-zA-Z]+)+$/){
			my @values = split ',',$inparams->{$param};
			push @itarray, \@values;
		} elsif($inparams->{$param} =~ /^[a-zA-Z]+$|^\d+(\.\d+)?$/){
			push @itarray, [$inparams->{$param}];
		} else {
			die "Could not successfully parse string given for $param\n";
		}
	}
	my @allarray;
	
	NestedLoops(\@itarray, sub {push @allarray, [ @_ ]});
	
	my %iterhash;
	foreach my $it (0 .. $#allarray){
		$iterhash{$it+1} = {map { $paramarray[$_] => $allarray[$it][$_] } 0..$#paramarray};
	}
	return \%iterhash;
}

sub line {
	my ($path,$line) = @_;
	open my $fh, '<', $path;
	while (<$fh>) {
		chomp $_;
		return $_ if $. == $line;
	}
}

sub find_pairs {
	my @allfiles = @_;
	my %filepairs;
	foreach my $file (@allfiles){
	    my ($file_name,$dir)=fileparse($file);
	    if($file_name =~ /(.+)_R([1|2])/){
		$filepairs{$1}[$2-1] = $file;
	    }else{
		die "Input file $file does not contain '_R1' or '_R2' in name";
	    }
	}
	return %filepairs;
}

sub defhash{
	my ($hash) = @_;
	return any { defined ${$hash}{$_} } keys %{$hash};
}

sub timestamp{
my @time = localtime;
return sprintf "%02d:%02d:%02d",$time[2],$time[1],$time[0];
}

sub datestamp{
my @time = localtime;
return sprintf "%04d-%02d-%02d",$time[5]+1900,$time[4]+1,$time[3];
}
