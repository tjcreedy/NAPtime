#!/usr/bin/env perl
#By Thomas J Creedy, thomas@tjcreedy.co.uk

use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path remove_tree);
use File::Copy qw(move);
use File::Which;
use List::Util qw(all any max); 
use Algorithm::Loops qw(NestedLoops);
use Parallel::ForkManager;
use Time::HiRes qw(usleep);
use Cwd qw(cwd);
use Data::Dumper;

########################################################
# INITIALISE VARIABLES AND SET DEFAULTS
#

my $version = "0.0.4"; #02/04/2019
my $help;
my @files;
my $outpath;
my %parameters;
our $verbose;
my $threads = 1;
our $debug;

my $script = basename($0,());

# CREATE HELPFILE

my $usage =<<USAGE;

Description:

	This is $script version $version of the NGS Amplicon Pipeline. It takes in one or more fastq files and runs usearch110 fastq_filter on each, converting them into fasta files according to the specified maxee parameter (passed to -eemax).
	
	The headers of each output file are renamed to include the file name as a barcodelabel tag, and the output files are concatenated together to form a single fasta. Both the individual renamed and concatenated fasta are output.
	
	The script can run with the eemax parameter specified with a single value, in which case it outputs a fasta for each fastq file, or if parameter ranges are specified it will loop through every combination of all parameters and outputs a directory containing the fastas for each unique parameter. Multiple concatenated fastas will also be produced if iterating.
	
	A csv log file is also output, along with a single fasta called all_rename_[iteration#].fa for each iteration, that is the concatenation of all fastas output for that iteration.
	
	For more information, see https://github.com/tjcreedy/NAPtime/wiki/NAPconvert

Usage:

	Basic
	$script -input file.fq [file2.fq file3.fq] -output <dir> -eemax <n> [-threads <n>] [-verbose]
	
	Parameter exploration
	$script -input file.fq [file2.fq file3.fq] -output <dir> -eemax <n-n/n> [-threads <n>] [-v]

Arguments:

	          input:  One or more fastq files to convert to fasta.
	        outpath:  Path to a directory in which output files and the log table are written.
	          eemax:  A value or range to pass to USEARCH110 fastq_filter as a -fastq_maxee option
	        threads:  Number of CPU threads to use. Default 1.
	        verbose:  Reports on progress.
	           help:  Prints out this helpful message.

USAGE

# SET UP HEADER

my $timedate = timestamp()." ".datestamp();
my $timer = "100000";
my $title =<<TITLE;
  _   _          _____  _   _                 
 | \\ | |   /\\   |  __ \\| | (_)                
 |  \\| |  /  \\  | |__) | |_ _ _ __ ___   ___  
 | . ` | / /\\ \\ |  ___/| __| | '_ ` _ \\ / _ \\ 
 | |\\  |/ ____ \\| |    | |_| | | | | | |  __/ 
 |_| \\_/_/    \\_\\_|     \\__|_|_| |_| |_|\\___| 
TITLE


######################################################
# GET INPUTS AND PARSE
#

GetOptions("input=s{0,}"	=> \@files,
	   "outpath=s"		=> \$outpath,
	   "eemax=s"		=> \$parameters{eemax},
	   "threads=i"		=> \$threads,
	   "verbose"		=> \$verbose,
	   "debug"		=> \$debug,
	   "help"		=> \$help) or die "Error: Incorrect options, try \"$script --help\" for more information.\n";

# RUN HEADER

foreach my $line (split '\n',$title){
	print $line,"\n";
	usleep($timer);
}

print "\nWelcome. This is $script version $version, started at $timedate.\n";

print "$usage\n" and exit if($help);

if($debug){
	$verbose = 1;
	print "\n#### Running in debug mode ####\n\n"
}

print "\nChecking your parameters...\n" if $verbose;

# CHECK FOR INPUT FILES

if(scalar @files == 0){
	if($debug){
		warn "No input files, running for debug purposes only. There may be errors.\n";
	} else {
		die "I need me some files to work on, see \"$script --help\" for more information\n";
	}
}

my %names = map { my $a = basename($_, ()); $a =~ s/\..*$//; $a => $_} @files;

print "DEBUG: names hash:\n", Dumper \%names if $debug;

# CHECK CONVERSION

my $converttool = "usearch110";

die "Error: $converttool not found, is it installed and in the PATH?\n" if(! which $converttool);
die "Error: please specify --eemax, see \"$script --help\" for more information\n" if(!defined $parameters{eemax});

# CHECK OUTPUT DIRECTORY

if(!defined $outpath){
	die "Error: output directory must be specified, see \"$script --help\" for more information\n";
} else {
	make_path($outpath);
}


######################################################
# SET UP ITERATIONS
#

print "\nParsing iterations...\n" if $verbose;

print "DEBUG: Input parameters:\n",Dumper \%parameters if $debug;

my $iterations = parse_parameters(\%parameters);

print "DEBUG: Parsed iterations:\n", Dumper $iterations if $debug;

printf "\n$script will run %d iterations on each of %d file pairs\n", scalar keys %$iterations, scalar @files;


######################################################
# RUN CONVERSION
#

# INITIALISE FORKER AND VARIABLES

my $cpm = Parallel::ForkManager->new($threads);
my $done_iterations=0;
my %convert_log;
my %empty_check;
my $total =  (scalar keys %$iterations) * (scalar @files);
my $it_threads = int($threads/$total);
$it_threads = 1 if($it_threads < 1);

# SET UP COMPLETION CLEANER

$cpm->run_on_finish( sub {
	my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
	$done_iterations++;
	print "Completed $done_iterations/$total merging and filtering iterations\r";
	my $iter = $data_structure_reference->{iter};
	my $name = $data_structure_reference->{name};
	$empty_check{$iter} += (split(",", $data_structure_reference->{result}))[2];
	$convert_log{$iter}{$name} = $data_structure_reference->{result};
});

# DO CONVERSION

printf "\nStarting %d conversion iterations using $threads threads\n", scalar keys %$iterations if $verbose;

foreach my $iter (keys %$iterations){
	make_path("$outpath/convert_$iter");
	foreach my $name (keys %names){
		my $pid = $cpm->start and next;
		
		my $out = convert($converttool,$iterations,$iter,\%names, $name,$outpath,$it_threads);
		
		$cpm->finish(0, {result => $out, iter => $iter, name => $name});
	}
#	remove_tree("$outpath/convert_$iter") unless $debug;
}

# FINALISE

$cpm->wait_all_children;
print "\n";

print "DEBUG: empty_check values:\n", Dumper \%empty_check if $debug;

foreach my $iter (keys %$iterations){
	if($empty_check{$iter}){
		my $concatcmd = "cat $outpath/convert_$iter/*.fa > $outpath/all_rename_$iter.fa";
		system($concatcmd);
	} else {
		warn "\nWARNING: All input files were empty, no concatenated output produced\n\n";
	}
}

print "DEBUG: convert log:\n", Dumper \%convert_log if $debug;

# MOVE FILES IF ONLY ONE ITERATION

if(scalar keys %$iterations == 1){
	move "$outpath/convert_1/$_.fa", "$outpath/$_.fa" for keys %names;
	remove_tree("$outpath/convert_1/");
}


######################################################
# DO LOG OUTPUT
#


#Do logging
open my $log, '>', "$outpath/convert.log.csv" or die "Error opening csv log for writing"; #open csv object for writing, and name

print $log join(',',('seqname' , 'iteration' ,'Max_expected_E-value', 'Filter_input_reads' , 'Filter_discarded' , 'Filter_converted')),"\n";

foreach my $iter (sort keys %$iterations){
	foreach my $name (sort keys %names){
		print $log "$name,$iter$convert_log{$iter}{$name}\n";
	}
}

close $log;

print "\nDone: CSV log of read processing written\n";

exit;

sub convert {
	# Load variables
	my ($converttool, $iterations, $iter, $names, $name, $outpath, $it_threads) = @_;
	
	# Do logging
	my $log = ",${$iterations}{$iter}{eemax}";
	
	if(! -z ${$names}{$name}){
		# CONVERSION
		
		print "Running $converttool fastq_filter on file $name for iteration $iter with eemax ${$iterations}{$iter}{eemax}\n" if $verbose;
		
		# Create command
		my $convert_cmd = "$converttool -fastq_filter ${$names}{$name} -fastaout $outpath/convert_$iter/$name.fa -fastq_maxee ${$iterations}{$iter}{eemax} -threads $it_threads 2>&1 1>/dev/null";
		
		# Run command
		print "DEBUG: fastq_filter command:\n$convert_cmd\n" if $debug;
		my $convert_log = `$convert_cmd`; 
		
		print "DEBUG: fastq_filter log:\n$convert_log\n" if $debug;
		
		# Parse log
		$convert_log =~ /.*\s(\d*)\s\sReads.*\s(\d*)\s\sDiscarded.*\s(\d*)\s\sFiltered.*/s; #regex to extract data
		my @convert_parse = ($1,$2,$3);
		foreach my $e (@convert_parse){
			if($e){
				$e =~ s/,//g;
				$log .= ",$e";
			} else {
				$log .= ",0";
			}
		}
		
		# HEADER RENAMING
		
		my $readlabelcmd = "sed -i -e \"s/^>\\([^ ]*\\)\\(.*\\)/>\\1;barcodelabel=$name;/\" $outpath/convert_$iter/$name.fa"; #Append sample name to reads within paired read file. note the double ecaping for sed expression within quoted string
		system($readlabelcmd);
		
	} else {
		print "File ${$names}{name} is empty, conversion skipped\n" if $verbose;
		$log .= ",0,0,0";
	}
	
	# Finish
	return $log;
}

sub parse_parameters {
	my ($inparams) = @_;
	my @itarray;
	my @paramarray;
	foreach my $param (keys %$inparams){
		push @paramarray, $param;
		if ($inparams->{$param} =~ /^(\d+(\.\d+)?)-(\d+(\.\d+)?),(\d+(\.\d+)?)$/ ){
			my @values;
			my $curmax = $1;
			while ($curmax <= $3){
				push @values, $curmax;
				$curmax += $5;
			}
			push @itarray, \@values;
		} elsif($inparams->{$param} =~ /^[a-zA-Z]+(?:,[a-zA-Z]+)+$/){
			my @values = split ',',$inparams->{$param};
			push @itarray, \@values;
		} elsif($inparams->{$param} =~ /^[a-zA-Z]+$|^\d+(\.\d+)?$/){
			push @itarray, [$inparams->{$param}];
		} else {
			die "Could not successfully parse string given for $param\n";
		}
	}
	my @allarray;
	
	NestedLoops(\@itarray, sub {push @allarray, [ @_ ]});
	
	my %iterhash;
	foreach my $it (0 .. $#allarray){
		$iterhash{$it+1} = {map { $paramarray[$_] => $allarray[$it][$_] } 0..$#paramarray};
	}
	return \%iterhash;
}

sub timestamp{
my @time = localtime;
return sprintf "%02d:%02d:%02d",$time[2],$time[1],$time[0];
}

sub datestamp{
my @time = localtime;
return sprintf "%04d-%02d-%02d",$time[5]+1900,$time[4]+1,$time[3];
}
