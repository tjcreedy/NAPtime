#!/usr/bin/env perl
#By Thomas J Creedy, thomas@tjcreedy.co.uk

use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path remove_tree);
use File::Copy qw(move);
use File::Which;
use List::Util qw(all any max); 
use Algorithm::Loops qw(NestedLoops);
use Parallel::ForkManager;
use Time::HiRes qw(usleep);
use Cwd qw(cwd);
use Data::Dumper;

########################################################
# INITIALISE VARIABLES AND SET DEFAULTS
#

my $version = "0.0.2"; #12/03/2019
my $help;
my @files;
my $outpath;
my %itsx;
my %primers;
our $verbose;
my $threads = 1;
our $debug;

my $script = basename($0,());

# CREATE HELPFILE

my $usage =<<USAGE;

Description:

	This is $script version $version of the NGS Amplicon Pipeline. It takes in a pair or set of paired files, such as those output from NAPdemux, and carries out primer trimming by wrapping the excellent cutadapt.
	
	Supply a list of file pairs after the -input parameter. These should be uncompressed fastq file pairs (fasta files are not currently supported, but this can be added - please email me!). The order of the files does not matter, but pairs must have identical names up to an _R1 or _R2 in the file names. Pairs will then be identified.
	
	Trimmed files will be written to the directory specified by -outpath, which will be created if it doesn't already exist.
	
	Current supported trimming options are to either trim by length or by sequence. When trimming by length, supply a parameter to both the -forwardprimerl and -reverseprimerl options. Input 0 if no trimming is required for one end of the sequence. When trimming by sequence, either supply both a -fprimersequence and a -rprimersequence, or supply the path to a -primersfile. The latter should be a text document comprising the forward primer sequence on the first line and the reverse primer sequence on the second line. By default, reads are retained if the primer sequence is not found and trimmed. Optionally, when trimming by sequence, you may use the -stricttrim flag to discard both members of a mate pair if the primer sequence(s) are not found and trimmed in either or both reads.
	
	The -verbose flag can be used to print messages while running. The -threads option specifies the number of file pairs to trim using cutadapt simultaneously on different forks.
	
	For more information, see https://github.com/tjcreedy/NAPtime/wiki/NAPtrim

Usage:

	$script -in <file_R1.fq> <file_R2.fq> [<file2_R1.fq> <file2_R2.fq>] -out <trim/> -forwardprimerl 8 -rprimerlength 10 [-threads <n> -verbose]
	$script -in <file_R1.fq> <file_R2.fq> [<file2_R1.fq> <file2_R2.fq>] -out <trim/> -fprimersequence <ATCG> -rprimersequence <CTGA> [-stricttrim] [-threads <n> -verbose]
	$script -in <file_R1.fq> <file_R2.fq> [<file2_R1.fq> <file2_R2.fq>] -out <trim/> -primersfile <file.txt> [-stricttrim] [-threads <n> -verbose]

Arguments:

	          input:  A list of paired files to trim.
	        outpath:  Path to a directory in which output files and the log table are written.
	 forwardprimerl:  Number of bases to trim from the forward reads.
	 reverseprimerl:  Number of bases to trim from the reverse reads.
	fprimersequence:  A base sequence to trim from the forward reads.
	rprimersequence:  A base sequence to trim from the reverse reads.
	    primersfile:  Path to a file containing base sequences to trim - line 1 forward, line 2 reverse.
	     stricttrim:  Should read pairs not matching one or both primer sequences be discarded?
	        threads:  Number of CPU threads to use. Default 1.
	        verbose:  Reports on progress.
	           help:  Prints out this helpful message.

USAGE

# SET UP HEADER

my $timedate = timestamp()." ".datestamp();
my $timer = "100000";
my $title =<<TITLE;
  _   _          _____  _   _                 
 | \\ | |   /\\   |  __ \\| | (_)                
 |  \\| |  /  \\  | |__) | |_ _ _ __ ___   ___  
 | . ` | / /\\ \\ |  ___/| __| | '_ ` _ \\ / _ \\ 
 | |\\  |/ ____ \\| |    | |_| | | | | | |  __/ 
 |_| \\_/_/    \\_\\_|     \\__|_|_| |_| |_|\\___| 
TITLE


######################################################
# GET INPUTS AND PARSE
#

GetOptions("input=s{0,}"	=> \@files,
	   "outpath=s"		=> \$outpath,
	   "forwardprimerl=i"	=> \$primers{length}{forward},
	   "reverseprimerl=i"	=> \$primers{length}{reverse},
	   "fprimersequence=s"	=> \$primers{sequence}{forward},
	   "rprimersequence=s"	=> \$primers{sequence}{reverse},
	   "primersfile=s"	=> \$primers{sequence}{file},
	   "stricttrim"		=> \$primers{sequence}{strict},
	   "threads=i"		=> \$threads,
	   "verbose"		=> \$verbose,
	   "debug"		=> \$debug,
	   "help"		=> \$help) or die "Error: Incorrect options, try \"$script -help\" for more information.\n";

# RUN HEADER

foreach my $line (split '\n',$title){
	print $line,"\n";
	usleep($timer);
}

print "\nWelcome. This is $script version $version, started at $timedate.\n";

print "$usage\n" and exit if($help);

if($debug){
	$verbose = 1;
	print "\n#### Running in debug mode ####\n\n"
}

print "\nChecking your parameters...\n" if $verbose;


die "Error: I don't understand \"$ARGV[0]\"", scalar @ARGV > 1 ? " and following options" : "\n" if(scalar @ARGV > 0);

# VERIFY AND PAIR INPUT FILES

print "\nChecking your files...\n" if $verbose;

if(scalar @files == 0){
	if($debug){
		warn "No input files, running for debug purposes only. There may be errors.\n";
	} else {
		die "Error: I need me some files to work on, see \"$script -help\" for more information\n";
	}
}

my %paired_files = find_pairs(@files);
my $n_file_pairs = keys %paired_files;

# CHECK TRIMMING

my $trimtool = "cutadapt";
die "Error: $trimtool not found, is it installed and in the PATH?\n" if(! which $trimtool);

print "DEBUG: primers hash:\n", Dumper \%primers if $debug;

if(defhash(\%{$primers{length}})){
	
	die "Error: please specify either primer lengths or primer sequences for trimming, not both. Option -stricttrim only applies to sequence trimming. See \"$script -help\" for more information\n" if defhash(\%{$primers{sequence}});
	die "Error: you must specify the lengths of both forward and revers primers for length trimming, see \"$script -help\" for more information\n" unless ($primers{length}{forward} and $primers{length}{reverse});
	print "Warning: primer trimming based on length is less accurate than trimming based on sequence. If you have the primer sequences, I suggest you use them\n";
	
} elsif(defhash(\%{$primers{sequence}})){
	
	if($primers{sequence}{file}){
		
		die "Error: please specify either both primer sequences or the path to a file containing primer sequences, see \"$script -help\" for more information\n" if( $primers{sequence}{forward} or $primers{sequence}{reverse} );
		$primers{sequence}{forward} = line($primers{sequence}{file},1) or die "Error: cannot read or parse primer file\n";
		$primers{sequence}{reverse} = line($primers{sequence}{file},2) or die "Error: cannot read or parse primer file\n";
		
	} else {
		
		die "Error: please specify both forward and reverse primer sequences, see \"$script -help\" for more information\n" unless( $primers{sequence}{forward} and $primers{sequence}{reverse} );
		
	}
	
	print "Warning: you have not specified -stricttrim: reads with poor adapter matches will not be trimmed, but will be retained in the dataset. See \"$script -help\" for more information\n" unless $primers{sequence}{strict}
	
} else {
	
	die "Error: please specify some primer details, either lengths or sequences, see \"$script -help\" for more information\n";
	
}

# CHECK OUTPUT DIRECTORY

if(!defined $outpath){
	die "Error: output directory must be specified, see \"$script -help\" for more information\n";
} else {
	make_path($outpath);
}


######################################################
# RUN TRIMMING
#

make_path("$outpath");

# INITIALISE FORKER AND VARIABLES

my $tpm = Parallel::ForkManager->new($threads);
my $done_trims=0;
my %trim_log;

# SET UP COMPLETION CLEANER

$tpm->run_on_finish( sub {
	my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
	$done_trims++;
	printf "Completed trimming $done_trims/%d file pairs\r", scalar keys %paired_files;
	my $name = $data_structure_reference->{name};
	$trim_log{$name} = $data_structure_reference->{result};
});

# DO TRIMMING

printf "\nTrimming %d file pairs using $threads threads\n", scalar keys %paired_files if $verbose;

foreach my $name (keys %paired_files){
	my $pid = $tpm->start and next;
	
	my $out = trim($trimtool,\%paired_files,$name,\%primers,$outpath);
	
	$tpm->finish(0, {result => $out, name => $name});
}

# FINALISE

$tpm->wait_all_children;
print "\n";
print "DEBUG: trim log:\n", Dumper \%trim_log, "\n" if $debug;

######################################################
# DO LOG OUTPUT
#


#Do logging
open my $log, '>', "$outpath/trim.log.csv" or die "Error opening csv log for writing"; #open csv object for writing, and name

print $log join(',',('readname','Input_reads','Pairs_untrimmed_removed')),"\n";

foreach my $name (sort keys %paired_files){
	print $log join(',', ($name,$trim_log{$name})),"\n";
}


close $log;

print "\nDone: CSV log of read processing written\n";

exit;

sub trim {
	# Load variables
	my ($trimtool,$pairs,$name,$primers,$outpath) = @_;
	my $cutspec;
	
	# Start log line
	my $log;
	
	# Create command
	if(defhash(${$primers}{length})){
		print "Trimming file pair $name based on primer lengths\n" if $verbose;
		$cutspec = "-u ${$primers}{length}{forward} -U ${$primers}{length}{reverse}";
	} else {
		print "Trimming file pair $name based on primer sequences\n" if $verbose;
		$cutspec = "-g ${$primers}{sequence}{forward} -G ${$primers}{sequence}{reverse}";
		$cutspec .= " --discard-untrimmed" if ${$primers}{sequence}{strict};
	}
	
	my $trim_cmd = "$trimtool $cutspec --minimum-length 1 --pair-filter any -o $outpath/trim/$name\_R1.fq -p $outpath/trim/$name\_R2.fq ${$pairs}{$name}[0] ${$pairs}{$name}[1]";
	
	# Run command
	print "DEBUG: $trimtool command:\n$trim_cmd\n" if $debug;
	
	my $trim_log = `$trim_cmd`;
	
	print "DEBUG: $trimtool log:\n$trim_log\n" if $debug;
	
	# Parse log
	$trim_log =~ /Total read pairs processed:[^\d]+(\d{1,3}(?:,\d{3})*)[^\d].*\(passing filters\):[^\d]+(\d{1,3}(?:,\d{3})*)[^\d]/s;
	my @trim_parse = ($1,$2);
	map { s/,//g; } @trim_parse;
	$trim_parse[1] = $trim_parse[0] - $trim_parse[1];
	$log = join ",",@trim_parse;
	
	# Finish
	return $log;
}

sub line {
	my ($path,$line) = @_;
	open my $fh, '<', $path;
	while (<$fh>) {
		chomp $_;
		return $_ if $. == $line;
	}
}

sub find_pairs {
	my @allfiles = @_;
	my %filepairs;
	foreach my $file (@allfiles){
	    my ($file_name,$dir)=fileparse($file);
	    if($file_name =~ /(.+)_R([1|2])/){
		$filepairs{$1}[$2-1]=$file;
	    }else{
		die "Input file $file does not contain '_R1' or '_R2' in name";
	    }
	}
	return %filepairs;
}

sub defhash{
	my ($hash) = @_;
	return any { defined ${$hash}{$_} } keys %{$hash};
}

sub timestamp{
my @time = localtime;
return sprintf "%02d:%02d:%02d",$time[2],$time[1],$time[0];
}

sub datestamp{
my @time = localtime;
return sprintf "%04d-%02d-%02d",$time[5]+1900,$time[4]+1,$time[3];
}
